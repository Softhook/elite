Okay, let's simplify the refactoring plan for enemy.js into smaller, testable stages focusing on specific methods.

Simplified Refactoring Plan for Enemy.js
Goal: Improve readability, maintainability, and testability by breaking down large methods and isolating responsibilities.

Testing Strategy: Before each stage, identify key scenarios related to the method being refactored. Observe the current behavior (e.g., console logs, in-game actions). After refactoring, re-test those scenarios to ensure behavior remains identical.

Stage 1: Refactor updateCombatAI (Lines 898-951)

Problem: This method orchestrates targeting, state updates, movement, and firing.
Steps:
Keep updateCombatAI as the main orchestrator.
Ensure the helper methods it calls (updateTargeting, updateCombatState, getMovementTargetForState, performRotationAndThrust, performFiring) are clearly defined and handle their specific tasks. (Looks like this is already partially done).
Focus on the logic within updateCombatAI itself, like the "FORCED COMBAT MODE" handling. Ensure this logic is clear and easy to follow.
Testing: Test scenarios where a Hauler is attacked (should enter forced combat), and verify it correctly targets the attacker and uses combat states before returning to hauling.
Stage 2: Refactor updateCombatState (Lines 819-896)

Problem: Large switch statement handling transitions between combat states (IDLE, APPROACHING, ATTACK_PASS, REPOSITIONING, FLEEING).
Steps:
Create separate private helper methods for the logic within each case (e.g., _updateState_ATTACK_PASS(), _updateState_FLEEING()).
The main updateCombatState method becomes a simple switch that calls the appropriate helper based on this.currentState.
Ensure state transition logic (this.changeState(...)) remains clear within the helpers.
Testing: Test transitions between states:
Idle enemy detects player -> APPROACHING.
Approaching enemy gets close -> ATTACK_PASS.
Attack pass timer ends -> REPOSITIONING.
Repositioning enemy reaches target -> APPROACHING.
Damaged enemy gets attacked -> FLEEING.
Fleeing enemy gets far enough away -> PATROLLING/IDLE.


Stage 3: Refactor evaluateTargetScore (Lines 500-648)

Problem: Very complex method with nested conditions for scoring potential targets based on role, distance, damage, etc. Uses an IIFE for scope isolation, which can be refactored.
Steps:
Remove the IIFE wrapper.
Create separate helper methods for different scoring aspects:
_getAttackerBonus(target)
_getRoleSpecificScore(target, system) (This could have sub-helpers like _getPirateScore, _getPoliceScore)
_getDistancePenalty(target)
_getHullDamageBonus(target)
evaluateTargetScore calls these helpers sequentially to calculate the final score.
Testing: Test target selection in various scenarios:
Pirate choosing between player with cargo vs. empty player vs. other pirate.
Police choosing between wanted player vs. wanted pirate.
Hauler deciding whether to retaliate against attacker.
Stage 4: Refactor updateHaulerAI (Lines 1021-1188)

Problem: Handles multiple distinct behaviors: checking for attackers, combat/fleeing logic, and normal patrolling/station interaction/leaving system logic.
Steps:
Extract the initial "check for attackers and decide to fight/flee" logic into a helper method like _handleHaulerAttacked(system). This method would return true if combat/fleeing was initiated, false otherwise.
Extract the "normal hauler logic" (the switch statement for PATROLLING, NEAR_STATION, LEAVING_SYSTEM) into a separate helper method like _updateHaulerPatrolLogic(system).
updateHaulerAI becomes:
Call _handleHaulerAttacked. If it returns true, call updateCombatAI or updateFleeingAI and return.
Otherwise, call _updateHaulerPatrolLogic.
Call updatePhysics.
Testing:
Hauler patrolling normally.
Hauler arriving near station, waiting, then leaving.
Hauler being attacked (check fight/flee decision and subsequent behavior).
Hauler returning to patrolling after combat/fleeing.
Stage 5: Refactor takeDamage (Lines 2278-2300)

Problem: Handles attacker reference, damage distribution (shields/hull), destruction check, and random cargo drop.
Steps:
Keep the existing private helper methods (_handleAttackerReference, _applyDamageDistribution, _processDestruction, _handlePlayerKillConsequences, _checkRandomCargoDrop). (Looks like this is already done).
Ensure the main takeDamage method clearly orchestrates calls to these helpers.
Review the logic within each helper for clarity and potential simplification.
Testing:
Damage hitting shields only.
Damage breaking shields and hitting hull.
Damage destroying the ship (check explosion, cargo drop, player consequences).
Verify attacker reference is set correctly.
Start with Stage 1 (updateCombatAI) or Stage 2 (updateCombatState) as they involve breaking down complex control flow. Remember to test thoroughly after each small change.

