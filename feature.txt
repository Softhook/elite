Feature: Hyperspace Jump Stretch Effect

1. Description: This feature provides visual feedback during the hyperspace jump sequence. As a ship (player or enemy) charges its jump drive, its visual representation will progressively stretch along its forward axis. Upon completion of the charge, the ship disappears (handled by the state transition), creating a "snap" effect as the stretch instantly ceases. This enhances the feeling of engaging a powerful drive and transitioning to hyperspace.

2. Requirements:

Applies to Player and Enemies: The stretch effect must be visible on the player ship when GAME_STATE.JUMPING is active and on enemy ships when they initiate their jump sequence (e.g., upon reaching the jump point).
Proportional Stretch: The degree of visual stretch must directly correlate with the jump charge progress. No stretch at 0% charge, maximum stretch at 100% charge.
Axis Alignment: Stretching must occur along the ship's longitudinal axis (front-to-back), regardless of the ship's current rotation on screen.
State-Dependent: The effect is only active during the jump charge phase. It should not be visible before charging starts or after the jump occurs/is aborted.
Configurable Intensity: The maximum amount of stretch should be easily configurable via a constant (e.g., JUMP_MAX_STRETCH_FACTOR).
Clean Transition: The ship should instantly revert to its normal appearance when the jump state ends.
3. Implementation Plan:

Constants: Define JUMP_MAX_STRETCH_FACTOR (e.g., 8.0).
Player (Player.draw):
Check if gameStateManager.currentState === GAME_STATE.JUMPING.
If true, calculate chargeProgress = gameStateManager.jumpChargeTimer / JUMP_CHARGE_TIME.
Calculate stretchFactor = 1.0 + chargeProgress * (JUMP_MAX_STRETCH_FACTOR - 1.0).
Inside the push()/pop() block, after translate() and rotate(), apply scale(1, stretchFactor) (assuming ship sprite points "up" along local Y-axis when angle=0). Adjust axis if sprite orientation differs.
Enemy (Enemy.js):
Add state variables: this.isChargingJump = false;, this.jumpChargeTimer = 0;.
In Enemy.update(): When AI decides to jump (reaches jump point in LEAVING_SYSTEM state), set isChargingJump = true, stop velocity, and start incrementing jumpChargeTimer. If timer exceeds JUMP_CHARGE_TIME, mark enemy for removal.
In Enemy.draw(): Implement the same scaling logic as the player, using this.isChargingJump and this.jumpChargeTimer to calculate stretchFactor and apply scale().
State Management: Ensure GameStateManager handles the player's state transitions correctly, and the entity management system correctly removes enemies after their jump timer completes.
4. Potential Problems:

Incorrect Stretch Axis: If the ship's sprite isn't oriented as assumed (e.g., points right instead of up by default), the scale() function will stretch it sideways. Requires verifying sprite orientation and potentially swapping the scale() arguments (scale(stretchFactor, 1)).
Off-Center Scaling: If the ship's vertices are not defined symmetrically around the local (0,0) origin before rotation/scaling, the stretch effect might appear visually offset from the ship's perceived center.
Visual Artifacts: Very high stretch factors might cause thin lines or gaps in complex ship shapes, or make textures look distorted. May require adjusting the max factor or using simpler shapes during the stretch.
Enemy State Synchronization: Bugs in the enemy AI state machine could lead to enemies stretching indefinitely, not stretching at all, or not being removed after the jump. Requires careful testing of the enemy jump sequence.